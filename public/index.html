<!doctype html>
<html lang="en">
    <head>
        <style>
            #canvas {
                width: 600px;
                height: 600px;
                border: solid black 2px;
                border-radius: 15px;
                background-color: black;
            }
        </style>
        <meta charset="UTF-8">
        <title>Robotwar</title>
        <script type="text/javascript" src="js/lib/jquery-2.0.3.min.js"></script>
        <script type="text/javascript" src="js/lib/Queue.js"></script>
    </head>
    <body>
        <p>
            Hello World, Welcome to Robotwar.
        </p>
        <canvas id="canvas" width="600" height="600"></canvas>

        <script>
            var debugCountdown = 1500;
            var debugAnimationCounter = 0;
            var debugSimulationCounter = 0;

            var ROBOT_RADIUS = 5;
            var ROBOT_MAX_X = 256.0;
            var ROBOT_MAX_Y = 256.0;

            var arenaWidth = ROBOT_MAX_X + (ROBOT_RADIUS * 2);
            var arenaHeight = ROBOT_MAX_Y + (ROBOT_RADIUS * 2);

            var canvasEl = $('#canvas')[0];
            var canvasWidth = parseInt(canvasEl.width);
            var canvasHeight = parseInt(canvasEl.height);

            var scaleFactor = parseInt($('#canvas').attr('width')) / arenaWidth;

            function offsetX(x) {
                return scaleFactor * (ROBOT_RADIUS + x);
            }
            function offsetY(y) {
                return scaleFactor * (ROBOT_RADIUS + y);
            }

            var canvasEl = $('#canvas')[0];
            var ctx = canvasEl.getContext('2d');
            ctx.fillStyle = "#6aea2a";
            
            var tickQueue = new Queue();
            var fastForward = 20;
            var GAME_SECONDS_PER_TICK = 0.03;
            var tickDuration = parseInt (GAME_SECONDS_PER_TICK / fastForward * 1000);

            var fps = 60;
            var frameDuration = parseInt (1000 / fps);

            var animationLoopId;

            var robotRadiusDisplay = ROBOT_RADIUS * scaleFactor;
            var radiansInCircle = Math.PI*2;
 
            function display(world) {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                world.robots.forEach(function(robot) {
                    ctx.beginPath();
                    ctx.arc(
                        offsetX(robot["pos-x"]), 
                        offsetY(robot["pos-y"]), 
                        robotRadiusDisplay, 
                        0, 
                        radiansInCircle, 
                        true);
                    ctx.fill();
                });
            }

            var worlds = (function() {
                var isFetching = false;
                return {
                    fetch: function() {
                        if (isFetching) {
                            return;
                        }
                        isFetching = true;
                        fetchWorlds(function() {
                            isFetching = false;
                        });
                    }
                };
            })();
           
            function simulationLoop(tick) {
                debugSimulationCounter++;
                if (tickQueue.isEmpty()) {
                    clearTimeout(animationLoopId);
                    return;
                }
                if (debugCountdown === 0) {
                    clearTimeout(animationLoopId);
                    return;
                }
                debugCountdown -= 1;
                console.log("tickQueue: " + tickQueue.getLength());

                if (tickQueue.getLength() < 500) {
                    worlds.fetch();
                }
                tickQueue.dequeue();
                var nextTick = tick + tickDuration;
                setTimeout(function() {
                    simulationLoop(nextTick);
                }, nextTick - Date.now()); 
            }

            function animationLoop(frame) {
                if (debugAnimationCounter % 100 === 0) {
                    console.log(debugSimulationCounter + " " + debugAnimationCounter);
                }
                debugAnimationCounter++;
                if (tickQueue.isEmpty()) {
                    return;
                }
                display(tickQueue.peek());
                var nextFrame = frame + frameDuration;
                animationLoopId = setTimeout(function() {
                    animationLoop(nextFrame);
                }, nextFrame - Date.now());
            }

            function fetchWorlds(callback) {
                $.getJSON('worlds/500', function(worlds) {
                    console.log("length of downloaded stuff: " + worlds.length);
                    tickQueue.enqueueArray(worlds);
                    if (callback) callback();
                });
            }

            fetchWorlds(function() {
                console.log(tickQueue.getLength());
                var now = Date.now();
                simulationLoop(now);
                animationLoop(now);
            });

        </script>
    </body>
</html>
