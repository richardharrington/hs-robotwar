<!doctype html>
<html lang="en">
    <head>
        <style>
            #canvas {
                width: 600px;
                height: 600px;
                border: solid black 2px;
                border-radius: 15px;
                background-color: black;
            }
        </style>
        <meta charset="UTF-8">
        <title>Robotwar</title>
        <script type="text/javascript" src="js/lib/jquery-2.0.3.min.js"></script>
        <script type="text/javascript" src="js/lib/Queue.js"></script>
    </head>
    <body>
        <p>
            Hello World, Welcome to Robotwar.
        </p>
        <canvas id="canvas" width="600" height="600"></canvas>

        <script>
            var debugAnimationCounter = 0;
            var debugSimulationCounter = 0;

            var ROBOT_RADIUS = 10;
            var ROBOT_MAX_X = 256.0;
            var ROBOT_MAX_Y = 256.0;

            var ROBOT_COLORS = ["#6aea2a", "#380bfa", "#fa2d0b", "#0bfaf7", "#faf20b"];

            var arenaWidth = ROBOT_MAX_X + (ROBOT_RADIUS * 2);
            var arenaHeight = ROBOT_MAX_Y + (ROBOT_RADIUS * 2);
            
            var canvas = (function(el) {
                var width = parseInt(el.width);
                var height = parseInt(el.height);
                var scaleFactor = parseInt(width / arenaWidth);
                var offsetX = function(x) {return scaleFactor * (ROBOT_RADIUS + x)};
                var offsetY = function(y) {return scaleFactor * (ROBOT_RADIUS + y)};
                var robotDisplayRadius = ROBOT_RADIUS * scaleFactor;
                var ctx = el.getContext('2d');

                var drawRobot = function(robot, idx) {
                    ctx.fillStyle = ROBOT_COLORS[idx];
                    ctx.beginPath();
                    ctx.arc(
                        offsetX(robot["pos-x"]), 
                        offsetY(robot["pos-y"]), 
                        robotDisplayRadius, 
                        0, 
                        Math.PI * 2,
                        true);
                    ctx.fill();
                }
                
                var draw = function(world) {
                    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                    world.robots.forEach(drawRobot);
                }

                return {draw: draw};
            })($('#canvas')[0]);

            var tickQueue = new Queue();
            var fastForward = 5;
            var GAME_SECONDS_PER_TICK = 0.03;

            // fastForward can't be more than 5 if we want tickDuration to be greater
            // than 6 milliseconds, which is close to the official 4-millisecond limit 
            // for setTimeout. TODO: set this as a limit in the user interface, 
            // and also look into how we can speed up by dropping ticks, while
            // still having things like having collisions happen when they're supposed
            // to happen. Perhaps if we make sure to animate collisions over 
            // several ticks, it will work.

            var tickDuration = parseInt (GAME_SECONDS_PER_TICK / fastForward * 1000);
            console.log(tickDuration);

            var fps = 60;
            var frameDuration = parseInt (1000 / fps);

            var animationLoopId;
            var debugTimeLoopInterval;

            var worlds = (function() {
                var isFetching = false;
                return {
                    fetch: function() {
                        if (isFetching) {
                            return;
                        }
                        isFetching = true;
                        fetchWorlds(function() {
                            isFetching = false;
                        });
                    }
                };
            })();
           
            function simulationLoop(tick) {
                debugSimulationCounter++;
                if (tickQueue.isEmpty()) {
                    clearTimeout(animationLoopId);
                    clearInterval(debugTimeLoopInterval);
                }
                if (tickQueue.isEmpty()) {
                    return;
                }
                if (tickQueue.getLength() < 500) {
                    worlds.fetch();
                }
                tickQueue.dequeue();
                var nextTick = tick + tickDuration;
                setTimeout(function() {
                    simulationLoop(nextTick);
                }, nextTick - Date.now()); 
            }

            function animationLoop(frame) {
                debugAnimationCounter++;
                if (tickQueue.isEmpty()) {
                    return;
                }
                canvas.draw(tickQueue.peek());
                var nextFrame = frame + frameDuration;
                animationLoopId = setTimeout(function() {
                    animationLoop(nextFrame);
                }, nextFrame - Date.now());
            }

            function debugTimeLoop() {
                var start = Date.now();
                debugTimeLoopInterval = setInterval(function() {
                    console.log(Math.floor((Date.now() - start) / 1000) + " " + debugAnimationCounter + " " + debugSimulationCounter);
                }, 1000);
            }

            function fetchWorlds(callback) {
                $.getJSON('worlds/500', function(worlds) {
                    tickQueue.enqueueArray(worlds);
                    if (callback) callback();
                });
            }

            fetchWorlds(function() {
                var now = Date.now();
                simulationLoop(now);
                animationLoop(now);
                debugTimeLoop();
            });

        </script>
    </body>
</html>
