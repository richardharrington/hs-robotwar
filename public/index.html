<!doctype html>
<html lang="en">
    <head>
        <style>
            #canvas {
                width: 600px;
                height: 600px;
                border: solid black 2px;
                border-radius: 15px;
                background-color: black;
            }
        </style>
        <meta charset="UTF-8">
        <title>Robotwar</title>
        <script type="text/javascript" src="js/lib/jquery-2.0.3.min.js"></script>
        <script type="text/javascript" src="js/lib/Queue.js"></script>
    </head>
    <body>
        <p>
            Hello World, Welcome to Robotwar.
        </p>
        <canvas id="canvas" width="600" height="600"></canvas>

        <script>
            var debugAnimationCounter = 0;
            var debugSimulationCounter = 0;

            var ROBOT_RADIUS = 10;
            var ROBOT_MAX_X = 256.0;
            var ROBOT_MAX_Y = 256.0;

            var arenaWidth = ROBOT_MAX_X + (ROBOT_RADIUS * 2);
            var arenaHeight = ROBOT_MAX_Y + (ROBOT_RADIUS * 2);

            var canvasEl = $('#canvas')[0];
            var canvasWidth = parseInt(canvasEl.width);
            var canvasHeight = parseInt(canvasEl.height);

            var scaleFactor = parseInt($('#canvas').attr('width')) / arenaWidth;

            function offsetX(x) {
                return scaleFactor * (ROBOT_RADIUS + x);
            }
            function offsetY(y) {
                return scaleFactor * (ROBOT_RADIUS + y);
            }

            var canvasEl = $('#canvas')[0];
            var ctx = canvasEl.getContext('2d');
            ctx.fillStyle = "#6aea2a";
            
            var tickQueue = new Queue();
            var fastForward = 5;
            var GAME_SECONDS_PER_TICK = 0.03;

            // fastForward can't be more than 5 if we want tickDuration to be greater
            // than 6 milliseconds, which is close to the official 4-millisecond limit 
            // for setTimeout. TODO: set this as a limit in the user interface, 
            // and also look into how we can speed up by dropping ticks, while
            // still having things like having collisions happen when they're supposed
            // to happen. Perhaps if we make sure to animate collisions over 
            // several ticks, it will work.

            var tickDuration = parseInt (GAME_SECONDS_PER_TICK / fastForward * 1000);
            console.log(tickDuration);

            var fps = 60;
            var frameDuration = parseInt (1000 / fps);

            var animationLoopId;
            var debugTimeLoopInterval;

            var robotRadiusDisplay = ROBOT_RADIUS * scaleFactor;
            var radiansInCircle = Math.PI*2;
 
            function display(world) {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                world.robots.forEach(function(robot) {
                    ctx.beginPath();
                    ctx.arc(
                        offsetX(robot["pos-x"]), 
                        offsetY(robot["pos-y"]), 
                        robotRadiusDisplay, 
                        0, 
                        radiansInCircle, 
                        true);
                    ctx.fill();
                });
            }

            var worlds = (function() {
                var isFetching = false;
                return {
                    fetch: function() {
                        if (isFetching) {
                            return;
                        }
                        isFetching = true;
                        fetchWorlds(function() {
                            isFetching = false;
                        });
                    }
                };
            })();
           
            function simulationLoop(tick) {
                debugSimulationCounter++;
                if (tickQueue.isEmpty()) {
                    clearTimeout(animationLoopId);
                    clearInterval(debugTimeLoopInterval);
                }
                if (tickQueue.isEmpty()) {
                    return;
                }
                if (tickQueue.getLength() < 500) {
                    worlds.fetch();
                }
                tickQueue.dequeue();
                var nextTick = tick + tickDuration;
                setTimeout(function() {
                    simulationLoop(nextTick);
                }, nextTick - Date.now()); 
            }

            function animationLoop(frame) {
                debugAnimationCounter++;
                if (tickQueue.isEmpty()) {
                    return;
                }
                display(tickQueue.peek());
                var nextFrame = frame + frameDuration;
                animationLoopId = setTimeout(function() {
                    animationLoop(nextFrame);
                }, nextFrame - Date.now());
            }

            function debugTimeLoop() {
                var start = Date.now();
                debugTimeLoopInterval = setInterval(function() {
                    console.log(Math.floor((Date.now() - start) / 1000) + " " + debugAnimationCounter + " " + debugSimulationCounter);
                }, 1000);
            }

            function fetchWorlds(callback) {
                $.getJSON('worlds/500', function(worlds) {
                    tickQueue.enqueueArray(worlds);
                    if (callback) callback();
                });
            }

            fetchWorlds(function() {
                var now = Date.now();
                simulationLoop(now);
                animationLoop(now);
                debugTimeLoop();
            });

        </script>
    </body>
</html>
